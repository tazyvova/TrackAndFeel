name: Deploy to VDS

on:
  workflow_run:
    workflows: ["Build & Push Images"]
    types: [completed]
    branches: [master]

permissions:
  contents: read
  packages: read

jobs:
  deploy:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    steps:
      # 1) Get only needed files into the runner workspace
      - uses: actions/checkout@v4
        with:
          sparse-checkout: |
            docker-compose.prod.yml
            Caddyfile
          sparse-checkout-cone-mode: false

      # 2) Create directory and prepare environment
      - name: SSH setup
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VDS_HOST }}
          username: ${{ secrets.VDS_USER }}
          key: ${{ secrets.VDS_SSH_KEY }}
          passphrase: ${{ secrets.VDS_SSH_PASSPHRASE }}
          script: |
            mkdir -p "${{ secrets.VDS_WORKDIR }}"

      # Basic file existence check
      - run: |
          pwd
          ls -la
          test -f docker-compose.prod.yml
          test -f Caddyfile

      # 3) Upload infra files to the VDS
      - name: Sync compose & configs to VDS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VDS_HOST }}
          username: ${{ secrets.VDS_USER }}
          key: ${{ secrets.VDS_SSH_KEY }}
          passphrase: ${{ secrets.VDS_SSH_PASSPHRASE }}
          source: "docker-compose.prod.yml,Caddyfile"
          target: ${{ secrets.VDS_WORKDIR }}
          overwrite: true

      # 4) Deploy via SSH
      - name: SSH into VDS and deploy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VDS_HOST }}
          username: ${{ secrets.VDS_USER }}
          key: ${{ secrets.VDS_SSH_KEY }}
          passphrase: ${{ secrets.VDS_SSH_PASSPHRASE }}
          script_stop: true
          command_timeout: 15m
          script: |
            set -euo pipefail
            cd "${{ secrets.VDS_WORKDIR }}"
            
            # Load local environment if it exists (Lightweight approach)
            if [ -f .env ]; then
              echo "✅ Loading environment from $(pwd)/.env"
              export $(grep -v '^#' .env | xargs)
            fi

            export COMMIT=${{ github.event.workflow_run.head_sha }}
            NEW_TAG="sha-${COMMIT:0:7}"

            CURRENT_BACKEND=$(docker inspect --format '{{.Config.Image}}' trackandfeel-backend 2>/dev/null || true)
            CURRENT_FRONTEND=$(docker inspect --format '{{.Config.Image}}' trackandfeel-frontend 2>/dev/null || true)
            PREVIOUS_TAG=${CURRENT_BACKEND##*:}
            if [ -z "$PREVIOUS_TAG" ] || [ "$PREVIOUS_TAG" = "$CURRENT_BACKEND" ]; then
              PREVIOUS_TAG=${CURRENT_FRONTEND##*:}
            fi
            if [ -z "$PREVIOUS_TAG" ] || [ "$PREVIOUS_TAG" = "$CURRENT_FRONTEND" ]; then
              PREVIOUS_TAG="latest"
            fi

            echo "COMMIT=$COMMIT"
            echo "Deploying tag: $NEW_TAG (previous tag: $PREVIOUS_TAG)"
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin

            export IMAGE_TAG="$NEW_TAG"
            docker compose -f docker-compose.prod.yml pull
            docker compose -f docker-compose.prod.yml up -d --no-build --force-recreate
            docker compose -f docker-compose.prod.yml ps
            echo "Caddyfile content:"
            cat Caddyfile
            docker compose -f docker-compose.prod.yml restart caddy
            echo "Checking frontend version.txt:"
            docker compose -f docker-compose.prod.yml exec frontend ls -la /usr/share/nginx/html/version.txt || echo "version.txt not found"
            echo "Frontend logs:"
            docker compose -f docker-compose.prod.yml logs frontend | tail -10

            validate_deployment() {
              set +e
              echo "Starting health check loop..."
              for i in {1..20}; do
                # Use -f to fail on 4xx/5xx, -s for silent
                HEALTH=$(curl -ksf https://${DOMAIN}/healthz 2>&1)
                if [ $? -eq 0 ]; then
                  echo "✅ Services are responsive (healthz: ok)"
                  break
                fi
                echo "⏳ Waiting for services... ($i/20) - Error: $HEALTH"
                sleep 10
              done

              if [ $i -eq 20 ]; then
                echo "❌ Error: Services did not become ready in time"
                docker compose -f docker-compose.prod.yml ps
                docker compose -f docker-compose.prod.yml logs --tail=20
                set -e
                return 1
              fi

              EXPECTED_VERSION=$COMMIT
              echo "Verifying versions (Expected: ${EXPECTED_VERSION:0:7})..."

              DEPLOYED_VERSION=$(curl -ksf https://${DOMAIN}/version)
              echo "Backend version: '$DEPLOYED_VERSION'"
              if [ "$DEPLOYED_VERSION" != "$EXPECTED_VERSION" ]; then
                echo "❌ Backend version mismatch!"
                echo "   Got:      $DEPLOYED_VERSION"
                echo "   Expected: $EXPECTED_VERSION"
                set -e
                return 1
              fi

              FRONTEND_VERSION=$(curl -ksf https://${DOMAIN}/frontend-version)
              echo "Frontend version: '$FRONTEND_VERSION'"
              if [ "$FRONTEND_VERSION" != "$EXPECTED_VERSION" ]; then
                echo "❌ Frontend version mismatch!"
                echo "   Got:      $FRONTEND_VERSION"
                echo "   Expected: $EXPECTED_VERSION"
                set -e
                return 1
              fi

              echo "✅ Deployment verified successfully!"
              set -e
              return 0
            }

            if ! validate_deployment; then
              echo "Validation failed, rolling back to previous tag: $PREVIOUS_TAG"
              export IMAGE_TAG="$PREVIOUS_TAG"
              docker compose -f docker-compose.prod.yml up -d --no-build --force-recreate
              docker compose -f docker-compose.prod.yml ps
              exit 1
            fi

      # 5) Wait for services to be ready
      - name: Wait for deployment readiness
        run: |
          for i in {1..30}; do
            if curl -s https://open.trackpace.twc1.net/healthz | grep -q "ok"; then
              echo "Services are ready"
              break
            fi
            echo "Waiting for services... ($i/30)"
            sleep 10
          done
          if [ $i -eq 30 ]; then
            echo "Services did not become ready in time"
            exit 1
          fi

