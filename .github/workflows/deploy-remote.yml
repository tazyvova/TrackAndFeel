name: Deploy to VDS

on:
  workflow_run:
    workflows: ["Build & Push Images"]
    types: [completed]
    branches: [master]

permissions:
  contents: read
  packages: read

jobs:
  deploy:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    steps:
      # 1) Get only needed files into the runner workspace
      - uses: actions/checkout@v4
        with:
          sparse-checkout: |
            docker-compose.prod.yml
            Caddyfile
          sparse-checkout-cone-mode: false

      # 2) Create directory and prepare environment
      - name: SSH setup
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VDS_HOST }}
          username: ${{ secrets.VDS_USER }}
          key: ${{ secrets.VDS_SSH_KEY }}
          passphrase: ${{ secrets.VDS_SSH_PASSPHRASE }}
          script: |
            mkdir -p "${{ secrets.VDS_WORKDIR }}"

      # Basic file existence check
      - run: |
          pwd
          ls -la
          test -f docker-compose.prod.yml
          test -f Caddyfile

      # 3) Upload infra files to the VDS
      - name: Sync compose & configs to VDS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VDS_HOST }}
          username: ${{ secrets.VDS_USER }}
          key: ${{ secrets.VDS_SSH_KEY }}
          passphrase: ${{ secrets.VDS_SSH_PASSPHRASE }}
          source: "docker-compose.prod.yml,Caddyfile"
          target: ${{ secrets.VDS_WORKDIR }}
          overwrite: true

      # 4) Deploy via SSH
      - name: SSH into VDS and deploy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VDS_HOST }}
          username: ${{ secrets.VDS_USER }}
          key: ${{ secrets.VDS_SSH_KEY }}
          passphrase: ${{ secrets.VDS_SSH_PASSPHRASE }}
          script_stop: true
          command_timeout: 15m
          script: |
            set -euo pipefail
            cd "${{ secrets.VDS_WORKDIR }}"
            export COMMIT=${{ github.event.workflow_run.head_sha }}
            echo "COMMIT=$COMMIT"
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin
            docker compose -f docker-compose.prod.yml pull
            docker compose -f docker-compose.prod.yml up -d --no-build --force-recreate
            docker compose -f docker-compose.prod.yml ps
            echo "Caddyfile content:"
            cat Caddyfile
            docker compose -f docker-compose.prod.yml restart caddy
            echo "Checking frontend version.txt:"
            docker compose -f docker-compose.prod.yml exec frontend ls -la /usr/share/nginx/html/version.txt || echo "version.txt not found"
            echo "Frontend logs:"
            docker compose -f docker-compose.prod.yml logs frontend | tail -10

      # 5) Wait for services to be ready
      - name: Wait for deployment readiness
        run: |
          for i in {1..30}; do
            if curl -s https://open.trackpace.twc1.net/healthz | grep -q "ok"; then
              echo "Services are ready"
              break
            fi
            echo "Waiting for services... ($i/30)"
            sleep 10
          done
          if [ $i -eq 30 ]; then
            echo "Services did not become ready in time"
            exit 1
          fi

      # 6) Verify deployed version
      - name: Verify deployed version
        run: |
          DEPLOYED_VERSION=$(curl -s https://open.trackpace.twc1.net/version)
          echo "Deployed backend version: '$DEPLOYED_VERSION'"
          EXPECTED_VERSION=${{ github.event.workflow_run.head_sha }}
          echo "Expected version: '$EXPECTED_VERSION'"
          if [ "$DEPLOYED_VERSION" != "$EXPECTED_VERSION" ]; then
            echo "Backend version mismatch: deployed=$DEPLOYED_VERSION, expected=$EXPECTED_VERSION"
            exit 1
          fi

          FRONTEND_VERSION=$(curl -s https://open.trackpace.twc1.net/frontend-version)
          echo "Deployed frontend version: '$FRONTEND_VERSION'"
          if [ "$FRONTEND_VERSION" != "$EXPECTED_VERSION" ]; then
            echo "Frontend version mismatch: deployed=$FRONTEND_VERSION, expected=$EXPECTED_VERSION"
            exit 1
          fi

          echo "Deployment verified: backend $DEPLOYED_VERSION, frontend $FRONTEND_VERSION"
